<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Measure</title>
    <style>
        #inputs {
            display: flex;
            flex-direction: row;
        }

        canvas {
            border: 1px solid black;
        }

        #export {
            height: 50vh;
            flex: 1;
        }
    </style>
</head>
<body>
<div id="inputs">
    <button onclick="zoom(-1)">-</button>
    <input placeholder="Scale" onchange="changeScale(event)" id="scale"/>
    <button onclick="zoom(1)">+</button>
    <form onsubmit="return addBox(event)">
        <select id="id">
            <option value="-1">New</option>
        </select>
        <input id="w" type="number" step="any" value="50" placeholder="Width">
        <input id="h" type="number" step="any" value="50" placeholder="Height">
        <input id="name" type="text" value="Test" placeholder="Name">
        <button type="submit">Add</button>
    </form>
    <button onclick="importRects()">Import</button>
</div>
<div style="display: flex">

    <canvas id="canvas" width="1000" height="1000"></canvas>
    
    <textarea id="export"></textarea>
    
</div>
<button onclick="exportImage()">Export Image</button>
<img id="png"/>
<script>
    let dragok = false;
    const settings = {
        scale: 1500, //meters
        rects: [],
        gridMultiplier: 10,
        ...JSON.parse(localStorage.getItem('settings') || '{}')
    }
    const rects = settings.rects;
    document.getElementById('scale').value = settings.scale;
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    ctx.font = "15px Helvetica";
    // listen for mouse events
    canvas.ondblclick = dblClick;
    canvas.onclick = myClick;
    canvas.onmousedown = myDown;
    canvas.onmouseup = myUp;
    canvas.onmousemove = myMove;


    draw();

    function exportImage() {
        const img = canvas.toDataURL('image/png');
        document.getElementById('png').src=img;
    }

    function exportRects() {
        const value = JSON.stringify(settings, null, 2);
        localStorage.setItem('settings', value);
        document.getElementById('export').value = value;
    }

    function importRects() {
        const {scale, rects: importRects = [], gridMultiplier} = JSON.parse(document.getElementById('export').value);
        settings.rects.splice(0, settings.rects.length, ...importRects);
        settings.scale = scale;
        settings.gridMultiplier = gridMultiplier;
        updateIds();
        draw();
    }

    function zoom(modifier) {
        const value = settings.scale + (10 * modifier);
        changeScale({target: {value}})
        document.getElementById('scale').value = value
    }

    function randomColor() {
        return '#' + Math.floor(Math.random() * 16777215).toString(16);
    }

    function changeScale(e) {
        const diff = settings.scale - +e.target.value;

        console.log('Offset by', diff);
        if (diff) {
            rects.forEach((rect) => {
                rect.x = rect.x + (+rect.x * diff / +e.target.value);
                rect.y = rect.y + (+rect.y * diff / +e.target.value);
            })
        }

        settings.scale = +e.target.value;
        draw()
    }

    function addBox(e) {
        e.preventDefault();
        const id = document.getElementById('id').value;
        const w = document.getElementById('w').value;
        const h = document.getElementById('h').value;
        const name = document.getElementById('name').value;

        if (id === '-1') {
            rects.push({
                w, h, color: randomColor(), x: 0, y: 0, name
            });
            updateIds();
        } else {
            rects[id] = {
                w, h, name,
                ...rects[id]
            }
        }

        draw();

        return false;
    }

    function updateIds() {
        const select = document.getElementById('id');
        select.innerHTML = '';
        const option = document.createElement("option");
        option.text = 'New';
        option.value = '-1';
        select.add(option)
        rects.forEach((_, i) => {
            const option = document.createElement("option");
            option.text = `${i}`;
            option.value = `${i}`;
            select.add(option)
        })
    }

    function draw() {
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        drawScale()
        drawGrid()
        rects.forEach(box => {
            const scaledWidth = +box.w / settings.scale * canvasWidth;
            const scaledHeight = +box.h / settings.scale * canvasWidth;
            ctx.strokeStyle = box.color;
            box.width = scaledWidth;
            box.height = scaledHeight;
            ctx.globalAlpha = 1;
            ctx.fillStyle = "black";
            ctx.fillText(`${box.name}`, box.x + 5, box.y + 15);
            ctx.fillText(`${box.w}`, box.x + (box.width / 2), box.y + (box.height - 15));
            ctx.fillText(`${box.h}`, box.x + (box.width - 55), box.y + (box.height / 2));
            ctx.globalAlpha = 0.5;
            ctx.fillStyle = box.color;
            ctx.fillRect(box.x, box.y, scaledWidth, scaledHeight);
            if (box.isDragging) {
                ctx.globalAlpha = 1;
                ctx.strokeStyle = '#000000';
                ctx.beginPath();
                ctx.rect(box.x, box.y, scaledWidth, scaledHeight);
                ctx.stroke();
            }
        })
        exportRects();
    }

    function drawGrid() {
        const pixelHeightIncrements = canvas.height / settings.scale;
        const pixelWidthIncrements = canvas.width / settings.scale;
        ctx.globalAlpha = 0.5;
        ctx.strokeStyle = '#000000';
        ctx.fillStyle = '#000000';
        // Rows
        for (let i = 0; i < canvas.height; i += pixelHeightIncrements * settings.gridMultiplier) {
            ctx.beginPath();
            ctx.moveTo(0, i);
            ctx.lineTo(canvas.width, i);
            ctx.stroke();
           
        }
        ctx.fillText(`${settings.gridMultiplier}`,pixelWidthIncrements * settings.gridMultiplier - 15,pixelHeightIncrements * settings.gridMultiplier / 2);
        
        // Columns
        for (let i = 0; i < canvas.width; i += pixelWidthIncrements * settings.gridMultiplier) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i, canvas.height);
            ctx.stroke();
        }
        ctx.fillText(`${settings.gridMultiplier}`,pixelWidthIncrements * settings.gridMultiplier / 2,pixelHeightIncrements * settings.gridMultiplier - 1);
    }

    function drawScale() {
        ctx.globalAlpha = 1;
        ctx.strokeStyle = '#000000';
        ctx.fillStyle = '#000000';
        // ctx.beginPath();
        // ctx.moveTo(0, 10);
        // ctx.lineTo(canvas.width, 10);
        // ctx.stroke();
        ctx.fillText(`${settings.scale}`, canvas.width / 2, 15);
    }

    function setValuesForIndex(index) {
        let rect = rects[index];

        document.getElementById('id').value = `${index}`;
        document.getElementById('w').value = rect.w;
        document.getElementById('h').value = rect.h;
        document.getElementById('name').value = rect.name;
    }

    function dblClick(e) {
        var BB = canvas.getBoundingClientRect();
        var offsetX = BB.left;
        var offsetY = BB.top;
        e.preventDefault();
        e.stopPropagation();
        var mx = parseInt(e.clientX - offsetX);
        var my = parseInt(e.clientY - offsetY);


        const rect = rects.find(r => (mx > r.x && mx < r.x + r.width && my > r.y && my < r.y + r.height));
        // rects.splice(rectIndex, 1);
        const temp = rect.w;
        rect.w = rect.h;
        rect.h = temp;
        draw();
    }

    function findClickedBox(e, indexOnly) {
        const BB = canvas.getBoundingClientRect();
        const offsetX = BB.left;
        const offsetY = BB.top;
        // tell the browser we're handling this mouse event
        e.preventDefault();
        e.stopPropagation();

        // get the current mouse position
        const mx = parseInt(e.clientX - offsetX);
        const my = parseInt(e.clientY - offsetY);

        // test each rect to see if mouse is inside

        const reverseRects = [...rects];
        reverseRects.reverse();
        const findMethod = r => (mx > r.x && mx < r.x + r.width && my > r.y && my < r.y + r.height);
        if (indexOnly) {
            return reverseRects.findIndex(findMethod);
        }
        return reverseRects.find(findMethod);
    }

    function myClick(e) {
        const rectIndex = findClickedBox(e, true);
        if (rectIndex > -1) {
            setValuesForIndex(rectIndex);
        } else {
            document.getElementById('id').value = `-1`;
        }

    }

    // handle mousedown events
    function myDown(e) {
        const BB = canvas.getBoundingClientRect();
        const offsetX = BB.left;
        const offsetY = BB.top;
        var mx = parseInt(e.clientX - offsetX);
        var my = parseInt(e.clientY - offsetY);
        const rect = findClickedBox(e)
        dragok = false;
        if (rect) {
            dragok = true;
            rect.isDragging = true;

        }

        // save the current mouse position
        startX = mx;
        startY = my;
    }


    // handle mouseup events
    function myUp(e) {
        // tell the browser we're handling this mouse event
        e.preventDefault();
        e.stopPropagation();

        // clear all the dragging flags
        dragok = false;
        for (var i = 0; i < rects.length; i++) {
            rects[i].isDragging = false;
        }
    }


    // handle mouse moves
    function myMove(e) {
        // if we're dragging anything...
        var BB = canvas.getBoundingClientRect();
        var offsetX = BB.left;
        var offsetY = BB.top;
        if (dragok) {

            // tell the browser we're handling this mouse event
            e.preventDefault();
            e.stopPropagation();

            // get the current mouse position
            var mx = parseInt(e.clientX - offsetX);
            var my = parseInt(e.clientY - offsetY);

            // calculate the distance the mouse has moved
            // since the last mousemove
            var dx = mx - startX;
            var dy = my - startY;

            // move each rect that isDragging
            // by the distance the mouse has moved
            // since the last mousemove
            for (var i = 0; i < rects.length; i++) {
                var r = rects[i];
                if (r.isDragging) {
                    r.x += dx;
                    r.y += dy;
                }
            }

            // redraw the scene with the new rect positions
            draw();

            // reset the starting mouse position for the next mousemove
            startX = mx;
            startY = my;

        }
    }
</script>
</body>
</html>
